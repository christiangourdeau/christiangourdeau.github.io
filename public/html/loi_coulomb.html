<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La loi de Coulomb</title>
    <style>
        /* --- Style Général --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --canvas-bg: #16213e;
            --text-color: #e0e0e0;
            --primary-color: #0f3460;
            
            /* --- Schéma de couleurs --- */
            --c1-color: #00ffff; /* Cyan */
            --c2-color: #9b59b6; /* Violet */
            --c3-color: #e94560; /* Rouge */
            --resultant-color: #ffff00; /* Jaune */
            --axis-color: #ffffff;      /* Blanc */
            
            --grid-color: rgba(255, 255, 255, 0.1);
            --font-main: 'Poppins', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 20px;
            display: flex; flex-direction: column;
            align-items: center; min-height: 100vh;
            box-sizing: border-box;
        }

        header { width: 100%; text-align: center; }
        h1 { font-weight: 600; color: var(--text-color); margin: 0; }
        h2, h3 { font-weight: 600; color: var(--text-color); }

        main#main-content {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        #simulation-interface {
            display: flex;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            gap: 10px;
            background-color: var(--bg-color);
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            width: 280px;
            flex-shrink: 0;
            background-color: var(--primary-color);
            padding: 40px 20px;
            box-sizing: border-box;
        }
        
        .controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        
        #canvas-container { flex-grow: 1; }
        canvas { display: block; background-color: var(--canvas-bg); cursor: grab; width: 100%; }
        canvas:active { cursor: grabbing; }
        
        .panel {
            background-color: var(--primary-color); padding: 15px 20px;
            border-radius: 8px;
            width: 100%; box-sizing: border-box;
        }
        
        #charge-count-selector { text-align: center; }
        #charge-count-selector h3 { margin-top: 0; margin-bottom: 10px; }
        #charge-count-selector label { margin: 0 15px; cursor: pointer; font-size: 1.1em; }

        #controls-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        .control-group {
            display: flex; flex-direction: column;
            align-items: center; gap: 8px; width: 100%;
        }
        .control-group label { font-weight: 600; font-size: 1.1em; }
        
        .control-group .charge-value {
            font-family: var(--font-mono);
            font-size: 1.2em;
            font-weight: bold;
            color: var(--text-color);
            background-color: transparent;
            padding: 0 8px 4px 8px;
            border: none;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0;
            min-width: 90px;
            text-align: center;
            margin-bottom: 5px;
        }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 220px; height: 8px; background: var(--bg-color); border-radius: 5px; outline: none; }
        
        input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; 
            cursor: pointer; border-radius: 50%; border: 2px solid var(--bg-color);
            background-color: var(--slider-color, #ccc);
        }
        input[type="range"]::-moz-range-thumb { 
            width: 20px; height: 20px; cursor: pointer; border-radius: 50%; 
            border: 2px solid var(--bg-color);
            background-color: var(--slider-color, #ccc);
        }
        
        #calculation-container {
            font-family: var(--font-mono); font-size: 0.95em; line-height: 1.7;
        }
        #calculation-container h2 { margin-top: 0; text-align: left; border-bottom: 2px solid var(--axis-color); padding-bottom: 5px; }
        .calculation-section { margin-bottom: 18px; padding-bottom: 12px; border-bottom: 1px solid var(--bg-color); }
        .calculation-section:last-child { border-bottom: none; margin-bottom: 0; }
        .formula-display { display: flex; align-items: center; justify-content: center; margin: 8px 0; font-size: 1.1em; }
        .fraction { display: inline-flex; flex-direction: column; text-align: center; vertical-align: middle; margin: 0 8px; }
        .numerator { padding: 0 5px; border-bottom: 1.5px solid var(--text-color); }
        .denominator { padding: 2px 5px 0 5px; }
        .vector { font-weight: bold; }
        .result { font-weight: bold; color: var(--resultant-color); }
    </style>
</head>
<body>

    <header>
        <h1>La loi de Coulomb</h1>
    </header>
    <p style="text-align: center; margin-top: -10px; margin-bottom: 20px; font-size: 14px; color: var(--text-color); opacity: 0.8;">
        Simulation conçue par Christian Gourdeau pour <a href="https://www.youtube.com/@laphysiquealachaine5938" target="_blank" style="color: white; font-weight: bold; text-decoration: none; display: inline-flex; align-items: center; gap: 4px;">La physique à la chaîne. <svg width="18" height="18" viewBox="0 0 24 24"><path fill="#FF0000" d="M21.582,6.186c-0.23-0.854-0.908-1.532-1.762-1.762C18.254,4,12,4,12,4S5.746,4,4.18,4.424c-0.854,0.23-1.532,0.908-1.762,1.762C2,7.754,2,12,2,12s0,4.246,0.418,5.814c0.23,0.854,0.908,1.532,1.762,1.762C5.746,20,12,20,12,20s6.254,0,7.82-0.424c0.854-0.23,1.532-0.908,1.762-1.762C22,16.246,22,12,22,12S22,7.754,21.582,6.186z"></path><path fill="#FFFFFF" d="M10,15.464V8.536L16,12L10,15.464z"></path></svg></a>
    </p>

    <main id="main-content">
        <div id="app-container">
            <div id="simulation-interface">
                <div id="left-panel">
                    <div class="controls-wrapper">
                        <div id="charge-count-selector">
                            <h3>Nombre de charges</h3>
                            <label><input type="radio" name="chargeCount" value="2"> 2</label>
                            <label><input type="radio" name="chargeCount" value="3" checked> 3</label>
                        </div>
                        <div id="controls-container"></div>
                    </div>
                </div>
                <div id="canvas-container">
                    <canvas id="physicsCanvas" width="850" height="600"></canvas>
                </div>
            </div>
            <div id="calculation-container" class="panel">
                <h2>Détails du Calcul</h2>
                <div id="calculation-details"></div>
            </div>
        </div>
    </main>
    
    <p style="text-align: center; margin-top: 20px; color: var(--text-color); opacity: 0.7; font-size: 12px;">
        Programmation réalisée avec l'aide de Google AI Studio.
    </p>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- SETUP: Constants and State Variables ---
        const canvas = document.getElementById('physicsCanvas');
        const ctx = canvas.getContext('2d');
        const k = 8.98755e9;
        const pixelsPerMeter = 100;
        const VECTOR_SCALE_TARGET_PIXELS = 150;
        
        const style = getComputedStyle(document.documentElement);
        const COLORS = {
            c1: style.getPropertyValue('--c1-color').trim(),
            c2: style.getPropertyValue('--c2-color').trim(),
            c3: style.getPropertyValue('--c3-color').trim(),
        };
        const RESULTANT_COLOR = style.getPropertyValue('--resultant-color').trim();
        const AXIS_COLOR = style.getPropertyValue('--axis-color').trim();
        const GRID_COLOR = style.getPropertyValue('--grid-color').trim();
        const FONT_MAIN = style.getPropertyValue('--font-main').trim();
        const FONT_MONO = style.getPropertyValue('--font-mono').trim();

        const allChargesPool = [
            { id: 'Q₁', color: COLORS.c1, x: -1.5, y: 1, q: 5e-6, radius: 15, isDragging: false },
            { id: 'Q₂', color: COLORS.c2, x: 1.5, y: 1, q: -5e-6, radius: 15, isDragging: false },
            { id: 'Q₃', color: COLORS.c3, x: 0, y: -1, q: 1e-6, radius: 15, isDragging: false },
        ];

        let activeCharges = [];
        let activeCharge = null;
        
        const controlsContainer = document.getElementById('controls-container');
        const calculationDetailsDiv = document.getElementById('calculation-details');
        const chargeCountRadios = document.querySelectorAll('input[name="chargeCount"]');

        // --- Coordinate Transformation ---
        const toCanvasX = (worldX) => canvas.width / 2 + worldX * pixelsPerMeter;
        const toCanvasY = (worldY) => canvas.height / 2 - worldY * pixelsPerMeter;
        const toWorldX = (canvasX) => (canvasX - canvas.width / 2) / pixelsPerMeter;
        const toWorldY = (canvasY) => (canvas.height / 2 - canvasY) / pixelsPerMeter;

        // --- Core Simulation Logic ---
        function calculateForces() {
            if (activeCharges.length < 2) return { forces: [], resultant: { x:0, y:0, mag:0, angle:0 }};
            const targetCharge = activeCharges[activeCharges.length - 1];
            const sources = activeCharges.slice(0, -1);
            let resultantForce = { x: 0, y: 0 };
            const individualForces = [];
            sources.forEach(source => {
                const dx = targetCharge.x - source.x; const dy = targetCharge.y - source.y;
                const r_sq = dx * dx + dy * dy;
                if (r_sq < 1e-4) { individualForces.push({ x: 0, y: 0, mag: 0, r: 0, source: source }); return; }
                const r = Math.sqrt(r_sq);
                const f_mag_signed = (k * source.q * targetCharge.q) / r_sq;
                const force = { x: f_mag_signed * (dx / r), y: f_mag_signed * (dy / r), mag: Math.abs(f_mag_signed), r: r, source: source };
                individualForces.push(force);
                resultantForce.x += force.x;
                resultantForce.y += force.y;
            });
            resultantForce.mag = Math.sqrt(resultantForce.x ** 2 + resultantForce.y ** 2);
            let angleDeg = Math.atan2(resultantForce.y, resultantForce.x) * (180 / Math.PI);
            if (angleDeg < 0) angleDeg += 360;
            resultantForce.angle = angleDeg;
            return { forces: individualForces, resultant: resultantForce, target: targetCharge };
        }

        // --- Drawing Functions ---
        function drawGridAndAxes() { const originX = toCanvasX(0); const originY = toCanvasY(0); const step = 0.5; const tickSize = 5; ctx.strokeStyle = GRID_COLOR; ctx.lineWidth = 0.5; const worldWidth = canvas.width / pixelsPerMeter; const worldHeight = canvas.height / pixelsPerMeter; for (let x = -Math.ceil(worldWidth/2); x <= Math.ceil(worldWidth/2); x += step) { ctx.beginPath(); ctx.moveTo(toCanvasX(x), 0); ctx.lineTo(toCanvasX(x), canvas.height); ctx.stroke(); } for (let y = -Math.ceil(worldHeight/2); y <= Math.ceil(worldHeight/2); y += step) { ctx.beginPath(); ctx.moveTo(0, toCanvasY(y)); ctx.lineTo(canvas.width, toCanvasY(y)); ctx.stroke(); } ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(canvas.width, originY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, canvas.height); ctx.stroke(); const arrowHeadSize = 10; ctx.fillStyle = AXIS_COLOR; ctx.beginPath(); ctx.moveTo(canvas.width, originY); ctx.lineTo(canvas.width - arrowHeadSize, originY - arrowHeadSize / 2); ctx.lineTo(canvas.width - arrowHeadSize, originY + arrowHeadSize / 2); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX - arrowHeadSize / 2, arrowHeadSize); ctx.lineTo(originX + arrowHeadSize / 2, arrowHeadSize); ctx.closePath(); ctx.fill(); ctx.fillStyle = AXIS_COLOR; ctx.font = `12px ${FONT_MONO}`; ctx.lineWidth = 1.5; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; for (let x = step; x * pixelsPerMeter < canvas.width / 2; x += step) { let cx = toCanvasX(x); ctx.beginPath(); ctx.moveTo(cx, originY - tickSize); ctx.lineTo(cx, originY + tickSize); ctx.stroke(); ctx.fillText(x, cx, originY + tickSize + 4); cx = toCanvasX(-x); ctx.beginPath(); ctx.moveTo(cx, originY - tickSize); ctx.lineTo(cx, originY + tickSize); ctx.stroke(); ctx.fillText(-x, cx, originY + tickSize + 4); } ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; for (let y = step; y * pixelsPerMeter < canvas.height / 2; y += step) { let cy = toCanvasY(y); ctx.beginPath(); ctx.moveTo(originX - tickSize, cy); ctx.lineTo(originX + tickSize, cy); ctx.stroke(); ctx.fillText(y, originX - tickSize - 4, cy); cy = toCanvasY(-y); ctx.beginPath(); ctx.moveTo(originX - tickSize, cy); ctx.lineTo(originX + tickSize, cy); ctx.stroke(); ctx.fillText(-y, originX - tickSize - 4, cy); } ctx.fillStyle = AXIS_COLOR; ctx.textAlign = 'right'; ctx.textBaseline = 'top'; const xLabelXPos = canvas.width - 5; const axisLabelYPos = originY + 25; ctx.font = `14px ${FONT_MAIN}`; ctx.fillText('(m)', xLabelXPos, axisLabelYPos); const unitMetricsX = ctx.measureText('(m)'); ctx.font = `italic 14px ${FONT_MAIN}`; ctx.fillText('x', xLabelXPos - unitMetricsX.width, axisLabelYPos); ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const yLabelYPos = 20; const axisLabelXPos = originX + 10; ctx.font = `italic 14px ${FONT_MAIN}`; ctx.fillText('y', axisLabelXPos, yLabelYPos); const varMetricsY = ctx.measureText('y'); ctx.font = `14px ${FONT_MAIN}`; ctx.fillText('(m)', axisLabelXPos + varMetricsY.width, yLabelYPos); }
        function drawArrow(fromX, fromY, toX, toY, color, lineWidth = 3) { const headlen = 10; const dx = toX - fromX; const dy = toY - fromY; const angle = Math.atan2(dy, dx); ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(toX, toY); ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6)); ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6)); ctx.closePath(); ctx.fillStyle = color; ctx.fill(); }
        function drawCharges() { activeCharges.forEach(charge => { const cx = toCanvasX(charge.x); const cy = toCanvasY(charge.y); ctx.beginPath(); ctx.arc(cx, cy, charge.radius, 0, 2 * Math.PI); ctx.fillStyle = charge.color; ctx.shadowColor = charge.color; ctx.shadowBlur = 15; ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#111111'; ctx.font = `bold ${charge.radius * 1.5}px ${FONT_MAIN}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(charge.q > 0 ? '+' : '−', cx, cy + 1); ctx.fillStyle = style.getPropertyValue('--text-color').trim(); ctx.font = `14px ${FONT_MAIN}`; ctx.fillText(charge.id, cx, cy - charge.radius - 8); }); }
        
        function drawForceVectors(calcResult, vectorScale) {
            if (vectorScale === 0 || !calcResult.target) return;
            const targetCharge = calcResult.target;
            const q_target_cx = toCanvasX(targetCharge.x); const q_target_cy = toCanvasY(targetCharge.y);
            if (calcResult.forces.length === 1) {
                const f = calcResult.forces[0];
                drawArrow(q_target_cx, q_target_cy, q_target_cx + f.x * vectorScale, q_target_cy - f.y * vectorScale, RESULTANT_COLOR, 5);
                return;
            }
            if (calcResult.forces.length === 2) {
                const f1 = calcResult.forces[0]; const f2 = calcResult.forces[1];
                const f1_endX = q_target_cx + f1.x * vectorScale; const f1_endY = q_target_cy - f1.y * vectorScale;
                const f2_endX = q_target_cx + f2.x * vectorScale; const f2_endY = q_target_cy - f2.y * vectorScale;
                const fr_endX = q_target_cx + calcResult.resultant.x * vectorScale; const fr_endY = q_target_cy - calcResult.resultant.y * vectorScale;
                ctx.setLineDash([4, 4]); ctx.lineWidth = 2;
                ctx.strokeStyle = f2.source.color; ctx.beginPath(); ctx.moveTo(f1_endX, f1_endY); ctx.lineTo(fr_endX, fr_endY); ctx.stroke();
                ctx.strokeStyle = f1.source.color; ctx.beginPath(); ctx.moveTo(f2_endX, f2_endY); ctx.lineTo(fr_endX, fr_endY); ctx.stroke();
                ctx.setLineDash([]);
                drawArrow(q_target_cx, q_target_cy, f1_endX, f1_endY, f1.source.color, 3);
                drawArrow(q_target_cx, q_target_cy, f2_endX, f2_endY, f2.source.color, 3);
            }
            drawArrow(q_target_cx, q_target_cy, q_target_cx + calcResult.resultant.x * vectorScale, q_target_cy - calcResult.resultant.y * vectorScale, RESULTANT_COLOR, 5);
        }

        function drawResultantInfo(calcResult) {
            if (!calcResult.target || calcResult.forces.length === 0) return;
            ctx.save();
            const magnitudeLabel = "Force résultante :";
            const angleLabel = "Angle :";
            const magnitudeValue = formatWithPrefix(calcResult.resultant.mag, 'N');
            const angleValue = `${calcResult.resultant.angle.toFixed(2)}°`;
            ctx.font = `15px ${FONT_MAIN}`;
            const magLabelWidth = ctx.measureText(magnitudeLabel).width;
            const angleLabelWidth = ctx.measureText(angleLabel).width;
            const labelWidth = Math.max(magLabelWidth, angleLabelWidth);
            ctx.font = `bold 15px ${FONT_MONO}`;
            const magValueWidth = ctx.measureText(magnitudeValue).width;
            const angleValueWidth = ctx.measureText(angleValue).width;
            const valueWidth = Math.max(magValueWidth, angleValueWidth);
            const boxPadding = 15;
            const spaceBetween = 10;
            const boxWidth = labelWidth + spaceBetween + valueWidth + boxPadding * 2;
            const boxHeight = 60;
            const boxX = 15;
            const boxY = 15;
            ctx.fillStyle = 'rgba(15, 30, 50, 0.85)';
            ctx.beginPath();
            ctx.rect(boxX, boxY, boxWidth, boxHeight);
            ctx.fill();
            const textXLabel = boxX + boxPadding;
            const textXValue = textXLabel + labelWidth + spaceBetween;
            const textY1 = boxY + 12;
            const textY2 = boxY + 35;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = AXIS_COLOR; 
            ctx.font = `15px ${FONT_MAIN}`;
            ctx.fillText(magnitudeLabel, textXLabel, textY1);
            ctx.fillText(angleLabel, textXLabel, textY2);
            ctx.font = `bold 15px ${FONT_MONO}`;
            ctx.fillText(magnitudeValue, textXValue, textY1);
            ctx.fillText(angleValue, textXValue, textY2);
            ctx.restore();
        }

        // --- UI & Display Functions ---
        function setupSlider(slider, charge, span) { 
            const update = () => { 
                const value = parseFloat(slider.value); 
                charge.q = value * 1e-6; 
                span.textContent = `${value.toFixed(2)} µC`; 
            }; 
            slider.addEventListener('input', update); 
            update(); 
        }
        
        function buildControls() {
            controlsContainer.innerHTML = '';
            activeCharges.forEach(charge => {
                const controlGroup = document.createElement('div'); controlGroup.className = 'control-group';
                
                const label = document.createElement('label'); 
                label.htmlFor = `q${charge.id.slice(1)}-slider`; 
                label.textContent = `Charge ${charge.id}`; 
                label.style.color = charge.color;
                
                const valueSpan = document.createElement('span'); 
                valueSpan.id = `q${charge.id.slice(1)}-value`; 
                valueSpan.className = 'charge-value';
                valueSpan.style.color = charge.color;
                
                const slider = document.createElement('input'); 
                slider.type = 'range'; 
                slider.id = `q${charge.id.slice(1)}-slider`; 
                slider.min = -10; slider.max = 10; 
                slider.value = charge.q * 1e6; 
                slider.step = 0.5;
                slider.style.setProperty('--slider-color', charge.color);

                controlGroup.append(label, valueSpan, slider);
                controlsContainer.appendChild(controlGroup);
                setupSlider(slider, charge, valueSpan);
            });
        }
        
        function formatWithPrefix(value, unit) { if (value === 0) return `0.00 ${unit}`; const absValue = Math.abs(value); let sign = value < 0 ? "-" : ""; if (unit === '' && value > 0 && absValue > 1e-12) sign = '+ '; if (unit === '' && value < 0) sign = '- '; if (absValue >= 1e9) return `${sign}${(absValue / 1e9).toFixed(2)} G${unit}`; if (absValue >= 1e6) return `${sign}${(absValue / 1e6).toFixed(2)} M${unit}`; if (absValue >= 1e3) return `${sign}${(absValue / 1e3).toFixed(2)} k${unit}`; if (absValue >= 1) return `${sign}${absValue.toFixed(2)} ${unit}`; if (absValue >= 1e-3) return `${sign}${(absValue * 1e3).toFixed(2)} m${unit}`; if (absValue >= 1e-6) return `${sign}${(absValue * 1e6).toFixed(2)} µ${unit}`; if (absValue >= 1e-9) return `${sign}${(absValue * 1e9).toFixed(2)} n${unit}`; if (absValue >= 1e-12) return `${sign}${(absValue * 1e12).toFixed(2)} p${unit}`; return value.toExponential(2) + ` ${unit}`; }
        
        function updateCalculationDisplay(calcResult) {
            if (!calcResult.target) { calculationDetailsDiv.innerHTML = ''; return; }
            const formatFix = (num) => num.toFixed(2);
            let html = '<div class="calculation-section"><strong>Données :</strong><br>';
            activeCharges.forEach(c => { html += `Q<sub>${c.id.slice(1)}</sub>: ${formatFix(c.q * 1e6)}µC à (${formatFix(c.x)}, ${formatFix(c.y)}) m<br>`; });
            html += '</div>';
            const targetIndex = calcResult.target.id.slice(1);
            calcResult.forces.forEach(force => {
                const sourceIndex = force.source.id.slice(1);
                html += `<div class="calculation-section"><strong>Force <span class="vector">F</span><sub>${sourceIndex}${targetIndex}</sub></strong><div class="formula-display"><span class="vector">F</span><sub>${sourceIndex}${targetIndex}</sub> = <div class="fraction"><span class="numerator">k |q<sub>${sourceIndex}</sub>q<sub>${targetIndex}</sub>|</span><span class="denominator">r<sub>${sourceIndex}${targetIndex}</sub><sup>2</sup></span></div></div>r<sub>${sourceIndex}${targetIndex}</sub> = ${formatFix(force.r)} m<br><span class="vector">F</span><sub>${sourceIndex}${targetIndex}x</sub> ≈ ${formatWithPrefix(force.x, 'N')}, <span class="vector">F</span><sub>${sourceIndex}${targetIndex}y</sub> ≈ ${formatWithPrefix(force.y, 'N')}</div>`;
            });
            if (calcResult.forces.length > 0) {
                let sumX = calcResult.forces.map(f => `${formatWithPrefix(f.x, 'N')}`).join(' ').replace(/ \+/g, ' + ').replace(/ -/g, ' - ');
                let sumY = calcResult.forces.map(f => `${formatWithPrefix(f.y, 'N')}`).join(' ').replace(/ \+/g, ' + ').replace(/ -/g, ' - ');
                let sumLabel = calcResult.forces.map(f => `<span class="vector">F</span><sub>${f.source.id.slice(1)}${targetIndex}</sub>`).join(' + ');
                html += `<div class="calculation-section"><strong>Force Résultante <span class="vector">F</span><sub>R</sub> sur Q<sub>${targetIndex}</sub></strong>`;
                if (calcResult.forces.length > 1) {
                    html += `<div class="formula-display"><span class="vector">F</span><sub>R</sub> = ${sumLabel}</div><span class="vector">F</span><sub>Rx</sub> = ${sumX} = ${formatWithPrefix(calcResult.resultant.x, 'N')}<br><span class="vector">F</span><sub>Ry</sub> = ${sumY} = ${formatWithPrefix(calcResult.resultant.y, 'N')}<br>`;
                }
                html += `<hr style="border-color: var(--bg-color); margin: 8px 0;">Magnitude: <span class="result">|<span class="vector">F</span><sub>R</sub>| ≈ ${formatWithPrefix(calcResult.resultant.mag, 'N')}</span><br>Angle: <span class="result">θ ≈ ${formatFix(calcResult.resultant.angle)}°</span></div>`;
            }
            calculationDetailsDiv.innerHTML = html;
        }

        // --- Main Loop and Event Handlers ---
        function mainLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGridAndAxes();
            const calcResult = calculateForces();
            const maxForceMag = Math.max(calcResult.resultant.mag, ...calcResult.forces.map(f => f.mag));
            const dynamicVectorScale = (maxForceMag > 0) ? VECTOR_SCALE_TARGET_PIXELS / maxForceMag : 0;
            drawForceVectors(calcResult, dynamicVectorScale);
            drawCharges();
            drawResultantInfo(calcResult);
            updateCalculationDisplay(calcResult);
            requestAnimationFrame(mainLoop);
        }

        function updateActiveCharges() { 
            const totalCharges = parseInt(document.querySelector('input[name="chargeCount"]:checked').value);
            activeCharges = allChargesPool.slice(0, totalCharges);
            buildControls(); 
        }
        
        chargeCountRadios.forEach(radio => radio.addEventListener('change', updateActiveCharges));
        
        canvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            for (let i = activeCharges.length - 1; i >= 0; i--) { const charge = activeCharges[i]; const cx = toCanvasX(charge.x); const cy = toCanvasY(charge.y); const dist = Math.sqrt((mousePos.x - cx)**2 + (mousePos.y - cy)**2); if (dist < charge.radius) { charge.isDragging = true; activeCharge = charge; break; } } });
        
        const stopDragging = () => { if (activeCharge) { activeCharge.isDragging = false; activeCharge = null; } };
        canvas.addEventListener('mouseup', stopDragging);
        
        canvas.addEventListener('mouseout', () => {
             stopDragging();
             canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const mousePos = getMousePos(e);
            canvas.style.cursor = activeCharge ? 'grabbing' : 'grab';
            
            if (activeCharge) {
                activeCharge.x = toWorldX(mousePos.x);
                activeCharge.y = toWorldY(mousePos.y);
            }
        });
        
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        // --- INITIALIZATION ---
        updateActiveCharges();
        mainLoop();
    });
    </script>
</body>
</html>