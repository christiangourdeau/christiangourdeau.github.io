<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation de Physique : Puissance & Intensité</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --primary-color: #e94560;
            --secondary-color: #0f3460;
            --text-color: #e0e0e0;
            --light-text-color: #a0a0c0;
            --canvas-bg: #16213e;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .page-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1920px;
        }
        
        .main-title {
            color: white;
            font-weight: 600;
            font-size: 2em;
            text-align: center;
            margin: 0;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 3.5fr 1fr; 
            gap: 30px;
            width: 100%;
            align-items: stretch;
        }

        .panel {
            background-color: var(--secondary-color);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
        }
        
        .simulation-container {
             position: relative;
             align-items: center;
             justify-content: center;
             padding: 20px;
        }
        
        h2 {
            text-align: center;
            color: white;
            font-weight: 600;
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 25px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        canvas {
            background-color: var(--canvas-bg);
            border-radius: 15px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
            width: 100%;
            height: auto;
            aspect-ratio: 4/3;
        }

        .controls .control-group {
            margin-bottom: 15px;
            transition: opacity 0.3s, max-height 0.3s ease-out, margin 0.3s, padding 0.3s;
            overflow: hidden;
        }
        .controls .control-group.hidden {
            opacity: 0;
            max-height: 0;
            margin-bottom: 0;
            padding: 0;
        }
        .controls .control-group:last-child {
            margin-bottom: 0;
        }
        .controls label {
            margin-bottom: 8px;
        }
        .controls .value-display {
            margin-top: 8px;
        }
        
        .value-display {
            display: block;
            text-align: center;
            font-weight: 600;
            color: var(--light-text-color);
            background-color: rgba(0,0,0,0.2);
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .value-display span {
            color: white;
            font-weight: 600;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            border-radius: 50%;
            border: 3px solid var(--bg-color);
            box-shadow: 0 0 5px var(--primary-color);
        }
        
        .results {
            justify-content: center;
        }
        .result-item { 
            margin-bottom: 22px; 
            text-align: center;
            transition: visibility 0s, opacity 0.3s linear;
        }
        .result-item.hidden {
            visibility: hidden;
            opacity: 0;
        }
        .result-item:last-child { margin-bottom: 0; }
        .result-item .result-title { 
            margin: 0; 
            font-size: 1.1em; 
            color: var(--text-color); 
            font-weight: 400; 
        }
        .result-item .formula { 
            display: block;
            font-size: 1.1em; 
            color: var(--light-text-color); 
            letter-spacing: 1px;
            margin-top: 8px;
        }
        .result-item .value-box-container {
            margin-top: 10px;
        }
        .result-item .value-box { 
            font-family: 'Poppins', sans-serif; 
            font-weight: 600; 
            color: white; 
            padding: 5px 15px; 
            background-color: rgba(233, 69, 96, 0.8); 
            border-radius: 8px; 
            min-width: 150px;
            display: inline-block;
        }
        
        sub, sup { font-size: 0.8em; line-height: 0; position: relative; vertical-align: baseline; }
        sup { top: -0.5em; }
        sub { bottom: -0.25em; }

        .toggle-switch { display: flex; align-items: center; }
        .toggle-switch label { margin: 0 10px 0 0; }
        .toggle-switch input[type="checkbox"] { height: 0; width: 0; visibility: hidden; }
        .toggle-switch .switch-body { cursor: pointer; width: 50px; height: 26px; background: #555; display: block; border-radius: 100px; position: relative; }
        .toggle-switch .switch-body:after { content: ''; position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: #fff; border-radius: 90px; transition: 0.3s; }
        .toggle-switch input:checked + .switch-body { background: var(--primary-color); }
        .toggle-switch input:checked + .switch-body:after { left: calc(100% - 3px); transform: translateX(-100%); }
        
        .duration-selector {
            display: flex;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        .duration-selector input[type="radio"] { display: none; }
        .duration-selector label {
            flex: 1;
            padding: 8px 5px;
            margin: 0;
            text-align: center;
            cursor: pointer;
            color: var(--light-text-color);
            background-color: transparent;
            transition: background-color 0.3s, color 0.3s;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
        }
        .duration-selector label:first-of-type { border-left: none; }
        .duration-selector input[type="radio"]:checked + label { background-color: var(--primary-color); color: white; font-weight: 600; }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

    <div class="page-wrapper">
        <h1 class="main-title">Énergie, puissance et intensité pour une source ponctuelle</h1>
        <p style="text-align: center; margin-top: -10px; margin-bottom: 20px; font-size: 14px; color: var(--light-text-color); opacity: 0.8;">
            Simulation conçue par Christian Gourdeau pour <a href="https://www.youtube.com/@laphysiquealachaine5938" target="_blank" style="color: white; font-weight: bold; text-decoration: none; display: inline-flex; align-items: center; gap: 4px;">La physique à la chaîne.<svg width="18" height="18" viewBox="0 0 24 24"><path fill="#FF0000" d="M21.582,6.186c-0.23-0.854-0.908-1.532-1.762-1.762C18.254,4,12,4,12,4S5.746,4,4.18,4.424c-0.854,0.23-1.532,0.908-1.762,1.762C2,7.754,2,12,2,12s0,4.246,0.418,5.814c0.23,0.854,0.908,1.532,1.762,1.762C5.746,20,12,20,12,20s6.254,0,7.82-0.424c0.854-0.23,1.532-0.908,1.762-1.762C22,16.246,22,12,22,12S22,7.754,21.582,6.186z"></path><path fill="#FFFFFF" d="M10,15.464V8.536L16,12L10,15.464z"></path></svg></a>
        </p>
        <div class="container">
            <!-- Colonne 1 : Paramètres -->
            <div class="panel controls">
                <h2>Paramètres</h2>
                <div class="control-group">
                    <label for="puissanceSlider">Puissance source (<i>P</i>)</label>
                    <input type="range" id="puissanceSlider" min="100" max="10000" value="5000" step="100">
                    <div id="puissanceValue" class="value-display"></div>
                </div>
                <div class="control-group">
                    <label for="distanceSlider">Distance de la source (<i>r</i>)</label>
                    <input type="range" id="distanceSlider" min="50" max="450" value="200" step="1">
                    <div id="distanceValue" class="value-display"></div>
                </div>
                <div class="control-group toggle-switch" id="sensorToggleGroup">
                    <label for="sensorToggle">Afficher le capteur</label>
                    <input type="checkbox" id="sensorToggle" />
                    <label for="sensorToggle" class="switch-body"></label>
                </div>
                <div class="control-group hidden" id="sensorSizeGroup">
                    <label for="tailleCapteurSlider">Dimension du capteur</label>
                    <input type="range" id="tailleCapteurSlider" min="10" max="150" value="80" step="1">
                    <div id="tailleCapteurValue" class="value-display"></div>
                </div>
                <div class="control-group hidden" id="sensorAngleGroup">
                    <label for="angleSlider">Angle du capteur (<i>&theta;</i>)</label>
                    <input type="range" id="angleSlider" min="-90" max="90" value="0" step="1">
                    <div id="angleValue" class="value-display"></div>
                </div>
                <div class="control-group hidden" id="durationGroup">
                    <label>Durée (&Delta;<i>t</i>)</label>
                    <div class="duration-selector">
                        <input type="radio" id="duree_1s" name="duree" value="1" checked>
                        <label for="duree_1s">1s</label>
                        <input type="radio" id="duree_2s" name="duree" value="2">
                        <label for="duree_2s">2s</label>
                        <input type="radio" id="duree_10s" name="duree" value="10">
                        <label for="duree_10s">10s</label>
                        <input type="radio" id="duree_1min" name="duree" value="60">
                        <label for="duree_1min">1min</label>
                        <input type="radio" id="duree_1h" name="duree" value="3600">
                        <label for="duree_1h">1h</label>
                    </div>
                </div>
            </div>

            <!-- Colonne 2 : Simulation -->
            <div class="panel simulation-container">
                <canvas id="physicsCanvas" width="800" height="600"></canvas>
            </div>

            <!-- Colonne 3 : Résultats -->
            <div class="panel results">
                <h2>Résultats</h2>
                <div class="result-item">
                    <p class="result-title">Intensité au capteur</p>
                    <p class="formula"><i>I</i> = <i>P</i> / 4&pi;<i>r</i><sup>2</sup></p>
                    <div class="value-box-container">
                        <span id="intensiteValue" class="value-box">...</span>
                    </div>
                </div>
                <div class="result-item hidden" id="effAreaResult">
                    <p class="result-title">Surface Effective</p>
                    <p class="formula"><i>A</i><sub>eff</sub> = <i>A</i>cos(<i>&theta;</i>)</p>
                    <div class="value-box-container">
                        <span id="aireEffectiveValue" class="value-box">...</span>
                    </div>
                </div>
                <div class="result-item hidden" id="powerResult">
                    <p class="result-title">Puissance Captée</p>
                    <p class="formula"><i>P</i><sub>capt</sub> = <i>I</i> <i>A</i><sub>eff</sub></p>
                    <div class="value-box-container">
                        <span id="puissanceCapteeValue" class="value-box">...</span>
                    </div>
                </div>
                <div class="result-item hidden" id="energyResult">
                    <p class="result-title">Énergie Captée</p>
                    <p class="formula"><i>E</i><sub>capt</sub> = <i>P</i><sub>capt</sub>&Delta;<i>t</i></p>
                    <div class="value-box-container">
                        <span id="energieValue" class="value-box">...</span>
                    </div>
                </div>
            </div>
        </div>
        <p style="text-align: center; margin-top: 10px; color: var(--light-text-color); font-size: 12px; opacity: 0.7;">
            Programmation réalisée avec l'aide de Google AI Studio.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('physicsCanvas');
        const ctx = canvas.getContext('2d');
        
        const puissanceSlider = document.getElementById('puissanceSlider');
        const distanceSlider = document.getElementById('distanceSlider');
        const sensorToggle = document.getElementById('sensorToggle');
        const tailleCapteurSlider = document.getElementById('tailleCapteurSlider');
        const angleSlider = document.getElementById('angleSlider');
        const dureeRadios = document.querySelectorAll('input[name="duree"]');
        
        const sensorSizeGroup = document.getElementById('sensorSizeGroup');
        const sensorAngleGroup = document.getElementById('sensorAngleGroup');
        const durationGroup = document.getElementById('durationGroup');
        
        const puissanceValueDisplay = document.getElementById('puissanceValue');
        const distanceValueDisplay = document.getElementById('distanceValue');
        const tailleCapteurValueDisplay = document.getElementById('tailleCapteurValue');
        const angleValueDisplay = document.getElementById('angleValue');
        
        const intensiteValueDisplay = document.getElementById('intensiteValue');
        const aireEffectiveValueDisplay = document.getElementById('aireEffectiveValue');
        const puissanceCapteeValueDisplay = document.getElementById('puissanceCapteeValue');
        const energieValueDisplay = document.getElementById('energieValue');
        const effAreaResult = document.getElementById('effAreaResult');
        const powerResult = document.getElementById('powerResult');
        const energyResult = document.getElementById('energyResult');

        const PIXEL_TO_METER = 0.02;
        const centerX = canvas.width / 3;
        const centerY = canvas.height / 2;
        
        const MIN_POWER_VAL = parseFloat(puissanceSlider.min);
        const MAX_POWER_VAL = parseFloat(puissanceSlider.max);
        
        function formatEnergy(joules) {
            if (joules >= 1e9) return `${(joules / 1e9).toFixed(3)} GJ`;
            if (joules >= 1e6) return `${(joules / 1e6).toFixed(3)} MJ`;
            if (joules >= 1e3) return `${(joules / 1e3).toFixed(3)} kJ`;
            return `${joules.toFixed(3)} J`;
        }
        
        function formatPower(watts) {
            if (watts >= 1) return `${watts.toFixed(3)} W`;
            if (watts >= 1e-3) return `${(watts * 1e3).toFixed(3)} mW`;
            if (watts >= 1e-6) return `${(watts * 1e6).toFixed(3)} µW`;
            return `${(watts * 1e9).toFixed(3)} nW`;
        }
        
        function updateUIState(showSensor) {
            const isHidden = !showSensor;
            sensorSizeGroup.classList.toggle('hidden', isHidden);
            sensorAngleGroup.classList.toggle('hidden', isHidden);
            durationGroup.classList.toggle('hidden', isHidden);
            
            effAreaResult.classList.toggle('hidden', isHidden);
            powerResult.classList.toggle('hidden', isHidden);
            energyResult.classList.toggle('hidden', isHidden);
        }

        function draw() {
            // 1. LIRE LES VALEURS
            const puissance = parseFloat(puissanceSlider.value);
            const distance = parseFloat(distanceSlider.value);
            const showSensor = sensorToggle.checked;
            const tailleCapteur = showSensor ? parseFloat(tailleCapteurSlider.value) : 0;
            const angle_deg = showSensor ? parseFloat(angleSlider.value) : 0;
            const angle_rad = angle_deg * (Math.PI / 180);
            
            // 2. CALCULS PHYSIQUES
            updateUIState(showSensor);
            const distance_m = distance * PIXEL_TO_METER;
            const intensite = puissance / (4 * Math.PI * Math.pow(distance_m, 2));

            if(showSensor) {
                const duree_s = parseFloat(document.querySelector('input[name="duree"]:checked').value);
                const tailleCapteur_m = tailleCapteur * PIXEL_TO_METER;
                const surfaceCapteur_m2 = Math.pow(tailleCapteur_m, 2);
                const surfaceEffective_m2 = surfaceCapteur_m2 * Math.cos(angle_rad);
                const puissanceCaptee = intensite * (surfaceEffective_m2 > 0 ? surfaceEffective_m2 : 0);
                const energieCaptee = puissanceCaptee * duree_s;
                
                aireEffectiveValueDisplay.innerHTML = `<span>${(surfaceEffective_m2 > 0 ? surfaceEffective_m2 : 0).toFixed(3)} m²</span>`;
                puissanceCapteeValueDisplay.innerHTML = `<span>${formatPower(puissanceCaptee)}</span>`;
                energieValueDisplay.innerHTML = `<span>${formatEnergy(energieCaptee)}</span>`;
            }

            // 3. MISE A JOUR DE L'INTERFACE
            puissanceValueDisplay.innerHTML = `<span>${puissance.toFixed(0)} W</span>`;
            distanceValueDisplay.innerHTML = `<span>${distance_m.toFixed(2)} m</span>`;
            tailleCapteurValueDisplay.innerHTML = `<span>${(tailleCapteur * PIXEL_TO_METER * 100).toFixed(1)} cm</span>`;
            angleValueDisplay.innerHTML = `<span>${angle_deg.toFixed(0)}°</span>`;
            intensiteValueDisplay.innerHTML = `<span>${intensite.toFixed(2)} W/m²</span>`;

            // 4. DESSIN DU CANVAS
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            const powerFraction = (puissance - MIN_POWER_VAL) / (MAX_POWER_VAL - MIN_POWER_VAL);
            const glowAlpha = 0.15 + Math.pow(powerFraction, 0.75) * 0.6;

            const lightGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width * 0.7);
            lightGradient.addColorStop(0, `rgba(255, 255, 220, ${glowAlpha * 0.7})`);
            lightGradient.addColorStop(0.3, `rgba(255, 200, 100, ${glowAlpha})`);
            lightGradient.addColorStop(0.7, `rgba(233, 69, 96, ${glowAlpha * 0.8})`);
            lightGradient.addColorStop(1, 'rgba(233, 69, 96, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const sensorIsOccluding = showSensor && Math.cos(angle_rad) > 0;
            if (sensorIsOccluding) {
                const sensor_pos_x = centerX + distance;
                const sensor_half_h = tailleCapteur / 2;
                const p1x = sensor_pos_x - sensor_half_h * Math.sin(angle_rad);
                const p1y = centerY + sensor_half_h * Math.cos(angle_rad);
                const p2x = sensor_pos_x + sensor_half_h * Math.sin(angle_rad);
                const p2y = centerY - sensor_half_h * Math.cos(angle_rad);
                const v1x = p1x - centerX, v1y = p1y - centerY;
                const v2x = p2x - centerX, v2y = p2y - centerY;
                const shadowLength = canvas.width * 2;
                const p3x = centerX + v1x * shadowLength, p3y = centerY + v1y * shadowLength;
                const p4x = centerX + v2x * shadowLength, p4y = centerY + v2y * shadowLength;
                
                const shadowPath = new Path2D();
                shadowPath.moveTo(p1x, p1y); shadowPath.lineTo(p2x, p2y); shadowPath.lineTo(p4x, p4y); shadowPath.lineTo(p3x, p3y);
                shadowPath.closePath();

                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fill(shadowPath);
                ctx.restore();

                ctx.save();
                const clipPath = new Path2D();
                clipPath.rect(0, 0, canvas.width, canvas.height);
                clipPath.addPath(shadowPath);
                ctx.clip(clipPath, 'evenodd');
            }

            const numLines = Math.floor(10 + powerFraction * 110);
            ctx.strokeStyle = `rgba(255, 255, 200, ${0.05 + powerFraction * 0.25})`;
            ctx.lineWidth = 1;
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * 2 * Math.PI;
                const endX = centerX + Math.cos(angle) * canvas.width;
                const endY = centerY + Math.sin(angle) * canvas.height;
                ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(endX, endY); ctx.stroke();
            }

            if (sensorIsOccluding) {
                ctx.restore();
            }

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.arc(centerX, centerY, distance, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (showSensor) {
                ctx.save();
                ctx.translate(centerX + distance, centerY); 
                ctx.rotate(angle_rad);
                ctx.fillStyle = 'white';
                ctx.fillRect(-2.5, -tailleCapteur / 2, 5, tailleCapteur);
                ctx.restore();
            }

            const sourceRadius = 5 + Math.sqrt(puissance) / 20;
            const sourceGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, sourceRadius * 2.5);
            sourceGlow.addColorStop(0, 'rgba(255, 255, 255, 1)');
            sourceGlow.addColorStop(0.3, 'rgba(255, 220, 100, 0.9)');
            sourceGlow.addColorStop(1, 'rgba(233, 69, 96, 0)');
            ctx.fillStyle = sourceGlow;
            ctx.fillRect(centerX - sourceRadius * 3, centerY - sourceRadius * 3, sourceRadius * 6, sourceRadius * 6);
            
            ctx.restore();
        }

        // EVENEMENTS
        ['input', 'change'].forEach(evt => {
            puissanceSlider.addEventListener(evt, draw);
            distanceSlider.addEventListener(evt, draw);
            tailleCapteurSlider.addEventListener(evt, draw);
            angleSlider.addEventListener(evt, draw);
        });
        sensorToggle.addEventListener('change', draw);
        dureeRadios.forEach(radio => radio.addEventListener('change', draw));
        
        window.onload = () => {
            updateUIState(sensorToggle.checked);
            draw();
        };
    </script>
</body>
</html>